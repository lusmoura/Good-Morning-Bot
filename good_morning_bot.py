import os
import pytz
import random 
import cohere
import logging
import psycopg2

import pandas as pd

from datetime import time
from dotenv import load_dotenv
from pytz import timezone

from telegram.ext import *
from telegram import Chat, InlineKeyboardButton, InlineKeyboardMarkup

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)
logger = logging.getLogger(__name__)

GET, FEEDBACK = range(2)

class TelegramBot:
    tones = ['Relaxed', 'Happy', 'Enthusiastic', 'Thoughtful', 'Inspirational', 'Romantic', 'Religious', 'Sad', 'Depressive', 'Angry']

    def __init__(self) -> None:
        load_dotenv()
        self.PORT = int(os.environ.get('PORT', '8443'))
        self.DB_URL = os.environ.get('DB_URL')
        self.DB_PASSWORD = os.environ.get('DB_PASSWORD')
        query = 'CREATE TABLE IF NOT EXISTS users (id integer);'
        self.write_to_db(query)
        query = 'CREATE TABLE IF NOT EXISTS messages (message varchar(500) primary key, tone varchar(50));'
        self.write_to_db(query)

    def start(self, update, context):
        logger.info('Start')
        text = 'Good Morning! Welcome to CohereGoodMorningBot, here you\'ll get the best good morning messages generated by our models according to your mood.'
        context.bot.send_message(chat_id=update.message.chat_id, text=text)
    
    def help(self, update, context):
        logger.info('Help')
        commands = '''Here\'s what I can do: 
        /start - Start.
        /get - Get new message.
        /subscribe - Receive daily good morning messages.
        /unsubscribe - Stop receiving daily messages.
        '''
        
        context.bot.send_message(chat_id=update.message.chat_id, text=commands)

    def pairwise(self, iterable):
        "s -> (s0, s1), (s2, s3), (s4, s5), ..."
        a = iter(iterable)
        return zip(a, a)

    def get_tone_buttons(self):
        buttons = []

        for tone1, tone2 in self.pairwise(self.tones):
            buttons.append([InlineKeyboardButton(text=tone1, callback_data=f'{tone1}'),
                        InlineKeyboardButton(text=tone2, callback_data=f'{tone2}')])
        
        markup = InlineKeyboardMarkup(buttons)
        return markup

    def get(self, update, context):
        logger.info('Get')
        buttons = self.get_tone_buttons()
        context.bot.send_message(chat_id=update.message.chat_id,
                                text='Which mood do you want for your message?',
                                reply_markup=buttons,
                                parse_mode='HTML'
                                )
        return GET

    def get_text(self, tone):
        query = f'''SELECT * FROM messages WHERE tone = '{tone}';'''
        result = self.read_from_db(query)

        if len(result) == 0:
            query = f'''SELECT * FROM messages'''
            result = self.read_from_db(query)

        prompt = ''
        for example in result:
            prompt += f'''Tone: {example['tone']}\nMessage: {example['message']}\n--\n'''
        prompt += f'Tone: {tone}\nMessage:'
        print(prompt)

        prediction = self.co.generate(
        model='xlarge',
        prompt=prompt,
        max_tokens=100,
        temperature=0.8,
        k=0,
        p=1,
        frequency_penalty=0,
        presence_penalty=0,
        stop_sequences=["--"],
        return_likelihoods='NONE')

        text = prediction.generations[0].text
        text = text.replace('--', '').strip()
        return text

    def write_to_db(self, query):
        conn = psycopg2.connect(self.DB_URL, sslmode='require', password=self.DB_PASSWORD)
        cur = conn.cursor()
        cur.execute(query)
        conn.commit()
        cur.close()

    def read_from_db(self, query):
        conn = psycopg2.connect(self.DB_URL, sslmode='require', password=self.DB_PASSWORD)
        user_data = pd.read_sql(query, conn)
    
        if len(user_data.to_dict('records')) == 0:
            return []

        return user_data.to_dict('records')

    def subscribe(self, update, context):
        chat_id = update.message.chat_id
        query = f"""INSERT INTO users(id) VALUES ({chat_id}) ON CONFLICT DO NOTHING;"""
        self.write_to_db(query)
        text = 'Done! You\'ll receive a daily good morning message!'
        context.bot.send_message(chat_id=chat_id, text=text)
    
    def unsubscribe(self, update, context):
        chat_id = update.message.chat_id
        query = f"""DELETE FROM users WHERE id= {chat_id}"""
        self.write_to_db(query)
        text = 'Okay! No more good morning messages for you =('
        context.bot.send_message(chat_id=chat_id, text=text)

    def send_random_message(self, context):
        logger.info('Sending scheduled message')
        users = self.read_from_db('''SELECT * FROM users''')[0]
        
        tone = random.choice(self.tones)
        text = self.get_text(tone)
        
        for id in users:
            context.bot.send_message(chat_id=id, text=f'Here\'s your scheduled message =D\nToday you\'ll get a {tone} message')
            context.bot.send_message(chat_id=id, text=text)

    def query_get_handler(self, update, context):
        query = update.callback_query
        query.answer()
        tone = query.data
        self.curr_tone = tone
        query.edit_message_text(text=f"Selected option: {tone}")
        text = self.get_text(tone)
        self.text=text
        context.bot.send_message(chat_id=update.effective_chat.id, text=text)

        keyboard = [
            [InlineKeyboardButton("Yes", callback_data="Yes")],
            [InlineKeyboardButton("No", callback_data="No")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        context.bot.send_message(chat_id=update.effective_chat.id,
                                text='Was this message appropriate to the mood?',
                                reply_markup=reply_markup,
                                parse_mode='HTML')

        return FEEDBACK

    def query_feedback_handler(self, update, context):
        query = update.callback_query
        query.answer()
        feedback = query.data

        if feedback == "Yes":
            text = self.text.replace("'", "\'")
            query_sql = f'''INSERT INTO messages(message, tone) VALUES ('{text}', '{self.curr_tone}') ON CONFLICT DO NOTHING;'''
            self.write_to_db(query_sql)
            query.edit_message_text(text=f"Yay! I\'ll keep on improving")
        else:
            query.edit_message_text(text=f"Damn, hope next time I get it right.")

        return ConversationHandler.END

    def unknown(self, update, context):
        logger.info('Unknown')
        text = "Sorry, I didn\'t get it =(\n Try /help for more info."
        context.bot.send_message(chat_id=update.message.chat_id, text=text)

    def error(self, update, context):
        logger.warning('Update "%s" caused error "%s"', update, context.error)

    def cancel(self, update, context):
        pass

    def run(self) -> None:
        logger.info('Starting')
        self.co = cohere.Client(os.environ.get('COHERE_API_KEY'))
        updater = Updater(token=os.environ.get('TELEGRAM_API_KEY'), use_context=True)
        dispatcher = updater.dispatcher
        job_queue = updater.job_queue

        start_handler = CommandHandler('start', self.start)
        dispatcher.add_handler(start_handler)

        help_handler = CommandHandler('help', self.help)
        dispatcher.add_handler(help_handler)

        conversation_handler = ConversationHandler(
            entry_points=[CommandHandler('get', self.get)],
            states={GET: [CallbackQueryHandler(self.query_get_handler)],
                    FEEDBACK: [CallbackQueryHandler(self.query_feedback_handler)],
            },
            fallbacks=[CommandHandler('cancel', self.cancel)]
        )
        dispatcher.add_handler(conversation_handler)

        subscribe_handler = CommandHandler('subscribe', self.subscribe)
        dispatcher.add_handler(subscribe_handler)

        unsubscribe_handler = CommandHandler('unsubscribe', self.unsubscribe)
        dispatcher.add_handler(unsubscribe_handler)

        unknown_handler = MessageHandler(Filters.command, self.unknown)
        dispatcher.add_handler(unknown_handler)

        dispatcher.add_error_handler(self.error)

        job_queue.run_daily(self.send_random_message, time=time(hour=8, minute=00, second=00, tzinfo=timezone('America/Sao_Paulo')))
    
        updater.start_webhook(
            listen="0.0.0.0",
            port=self.PORT,
            url_path=os.environ.get('TELEGRAM_API_KEY'),
            webhook_url=os.environ.get('APP_NAME') + os.environ.get('TELEGRAM_API_KEY')
        )
        
        # updater.start_polling(timeout=6000)
        updater.idle()

if __name__ == '__main__':
    bot = TelegramBot()
    try:
        bot.run()
    except Exception as e:
        logging.info(e.args)